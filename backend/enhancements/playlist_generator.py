#!/usr/bin/env python3
"""
Playlist Generator Enhancement for Spotify Wrapped
Auto-create playlists from your wrapped data
"""

import spotipy
from typing import List, Dict, Any, Optional
from datetime import datetime

class WrappedPlaylistGenerator:
    """Generate Spotify playlists from wrapped data."""
    
    def __init__(self, sp: spotipy.Spotify, user_id: str):
        self.sp = sp
        self.user_id = user_id
    
    def create_wrapped_playlist(self, 
                               tracks: List[Dict], 
                               name: Optional[str] = None,
                               description: Optional[str] = None,
                               public: bool = True) -> Dict[str, Any]:
        """Create a playlist from wrapped tracks."""
        
        if not tracks:
            return {'error': 'No tracks provided'}
        
        # Default playlist name and description
        if not name:
            year = datetime.now().year
            month = datetime.now().strftime('%B')
            name = f"My Wrapped {month} {year}"
        
        if not description:
            description = f"My top {len(tracks)} tracks - Generated by Spotify Wrapped Dashboard"
        
        try:
            # Create the playlist
            playlist = self.sp.user_playlist_create(
                user=self.user_id,
                name=name,
                public=public,
                description=description
            )
            
            # Extract track URIs
            track_uris = [f"spotify:track:{track['id']}" for track in tracks if track.get('id')]
            
            # Add tracks in batches (Spotify limits to 100 per request)
            for i in range(0, len(track_uris), 100):
                batch = track_uris[i:i+100]
                self.sp.playlist_add_items(playlist['id'], batch)
            
            return {
                'success': True,
                'playlist_id': playlist['id'],
                'playlist_url': playlist['external_urls']['spotify'],
                'tracks_added': len(track_uris),
                'name': name
            }
            
        except Exception as e:
            return {'error': str(e)}
    
    def create_multiple_playlists(self, time_ranges: List[str] = None) -> List[Dict]:
        """Create playlists for different time ranges."""
        
        if not time_ranges:
            time_ranges = ['short_term', 'medium_term', 'long_term']
        
        playlists_created = []
        
        for time_range in time_ranges:
            # Load tracks from storage
            tracks = storage.load_top_tracks(self.user_id, time_range)
            
            if tracks:
                # Determine playlist name based on time range
                range_names = {
                    'short_term': 'Last Month Favorites',
                    'medium_term': 'Last 6 Months Top Tracks', 
                    'long_term': 'All-Time Favorites'
                }
                
                name = f"My Wrapped: {range_names.get(time_range, time_range)}"
                description = f"My top {len(tracks)} tracks from {range_names.get(time_range, time_range)}"
                
                result = self.create_wrapped_playlist(
                    tracks[:50],  # Limit to top 50
                    name=name,
                    description=description
                )
                
                if result.get('success'):
                    playlists_created.append(result)
        
        return playlists_created
    
    def create_genre_playlists(self) -> List[Dict]:
        """Create playlists based on top genres."""
        
        playlists = []
        
        # Load all tracks
        all_tracks = []
        for time_range in ['short_term', 'medium_term', 'long_term']:
            tracks = storage.load_top_tracks(self.user_id, time_range) or []
            all_tracks.extend(tracks)
        
        # Load artists to get genre information
        all_artists = []
        for time_range in ['short_term', 'medium_term', 'long_term']:
            artists = storage.load_top_artists(self.user_id, time_range) or []
            all_artists.extend(artists)
        
        # Create genre to tracks mapping
        genre_tracks = {}
        
        for track in all_tracks:
            # Get track's artists
            for artist in track.get('artists', []):
                # Find artist in our artists list to get genres
                artist_data = next((a for a in all_artists if a['id'] == artist['id']), None)
                if artist_data:
                    for genre in artist_data.get('genres', []):
                        if genre not in genre_tracks:
                            genre_tracks[genre] = []
                        if track not in genre_tracks[genre]:
                            genre_tracks[genre].append(track)
        
        # Create playlists for top genres
        sorted_genres = sorted(genre_tracks.items(), key=lambda x: len(x[1]), reverse=True)
        
        for genre, tracks in sorted_genres[:5]:  # Top 5 genres
            if len(tracks) >= 10:  # Only create if we have enough tracks
                name = f"My Wrapped: {genre.title()}"
                description = f"My favorite {genre} tracks"
                
                result = self.create_wrapped_playlist(
                    tracks[:30],  # Max 30 tracks per genre
                    name=name,
                    description=description
                )
                
                if result.get('success'):
                    result['genre'] = genre
                    playlists.append(result)
        
        return playlists
    
    def create_mood_playlists(self) -> List[Dict]:
        """Create playlists based on audio features (mood)."""
        
        playlists = []
        
        # Load tracks
        tracks = storage.load_top_tracks(self.user_id, 'medium_term') or []
        
        if not tracks:
            return playlists
        
        # Get audio features
        track_ids = [t['id'] for t in tracks if t.get('id')]
        audio_features = self.sp.audio_features(track_ids)
        
        # Categorize tracks by mood
        happy_tracks = []
        sad_tracks = []
        energetic_tracks = []
        chill_tracks = []
        danceable_tracks = []
        
        for track, features in zip(tracks, audio_features):
            if features:
                if features['valence'] > 0.7:
                    happy_tracks.append(track)
                elif features['valence'] < 0.3:
                    sad_tracks.append(track)
                
                if features['energy'] > 0.7:
                    energetic_tracks.append(track)
                elif features['energy'] < 0.3:
                    chill_tracks.append(track)
                
                if features['danceability'] > 0.7:
                    danceable_tracks.append(track)
        
        # Create mood playlists
        mood_playlists = [
            ('Happy Vibes ‚òÄÔ∏è', 'Uplifting tracks to brighten your day', happy_tracks),
            ('Emotional Journey üåô', 'Deep, emotional tracks for contemplation', sad_tracks),
            ('Energy Boost ‚ö°', 'High-energy tracks to power through', energetic_tracks),
            ('Chill Zone üßò', 'Relaxing tracks for unwinding', chill_tracks),
            ('Dance Party üï∫', 'Get moving with these danceable hits', danceable_tracks)
        ]
        
        for name, desc, tracks_list in mood_playlists:
            if len(tracks_list) >= 10:
                result = self.create_wrapped_playlist(
                    tracks_list[:30],
                    name=f"My Wrapped: {name}",
                    description=desc
                )
                
                if result.get('success'):
                    result['mood'] = name
                    playlists.append(result)
        
        return playlists
    
    def create_discovery_playlist(self) -> Dict[str, Any]:
        """Create a playlist of recommended tracks based on wrapped data."""
        
        # Get top tracks and artists
        top_tracks = storage.load_top_tracks(self.user_id, 'short_term') or []
        top_artists = storage.load_top_artists(self.user_id, 'short_term') or []
        
        if not top_tracks or not top_artists:
            return {'error': 'Not enough data for recommendations'}
        
        # Get seed data (max 5 seeds total for Spotify API)
        seed_tracks = [t['id'] for t in top_tracks[:2] if t.get('id')]
        seed_artists = [a['id'] for a in top_artists[:2] if a.get('id')]
        seed_genres = []
        
        # Get top genre
        for artist in top_artists:
            if artist.get('genres'):
                seed_genres.append(artist['genres'][0])
                break
        
        try:
            # Get recommendations
            recommendations = self.sp.recommendations(
                seed_artists=seed_artists[:2],
                seed_tracks=seed_tracks[:2],
                seed_genres=seed_genres[:1],
                limit=30
            )
            
            # Format tracks
            rec_tracks = [{
                'id': track['id'],
                'name': track['name'],
                'artists': track['artists']
            } for track in recommendations['tracks']]
            
            # Create playlist
            return self.create_wrapped_playlist(
                rec_tracks,
                name="My Wrapped: Discover New Music üéµ",
                description="Fresh recommendations based on your favorites"
            )
            
        except Exception as e:
            return {'error': str(e)}
    
    def create_ultimate_wrapped_playlist(self) -> Dict[str, Any]:
        """Create the ultimate wrapped playlist combining all time ranges."""
        
        all_tracks = {}
        
        # Weight tracks by time range (recent gets higher weight)
        weights = {
            'short_term': 3,
            'medium_term': 2,
            'long_term': 1
        }
        
        for time_range, weight in weights.items():
            tracks = storage.load_top_tracks(self.user_id, time_range) or []
            
            for i, track in enumerate(tracks[:20]):  # Top 20 from each
                track_id = track.get('id')
                if track_id:
                    if track_id not in all_tracks:
                        all_tracks[track_id] = {
                            'track': track,
                            'score': 0
                        }
                    # Score based on position and weight
                    all_tracks[track_id]['score'] += (20 - i) * weight
        
        # Sort by score
        sorted_tracks = sorted(all_tracks.values(), key=lambda x: x['score'], reverse=True)
        final_tracks = [item['track'] for item in sorted_tracks[:50]]
        
        return self.create_wrapped_playlist(
            final_tracks,
            name=f"My Ultimate Wrapped {datetime.now().year} üèÜ",
            description="The perfect blend of your all-time and recent favorites"
        )

# Flask endpoint integration
def playlist_endpoints(app):
    """Add these endpoints to your Flask app."""
    
    @app.route('/api/create-playlist/<playlist_type>', methods=['POST'])
    def create_playlist(playlist_type):
        sp = get_spotify_client()
        if not sp:
            return jsonify({'error': 'Not authenticated'}), 401
        
        user_id = get_user_id()
        generator = WrappedPlaylistGenerator(sp, user_id)
        
        if playlist_type == 'current':
            time_range = request.json.get('time_range', 'medium_term')
            tracks = storage.load_top_tracks(user_id, time_range)
            result = generator.create_wrapped_playlist(tracks[:50])
        
        elif playlist_type == 'genre':
            result = generator.create_genre_playlists()
        
        elif playlist_type == 'mood':
            result = generator.create_mood_playlists()
        
        elif playlist_type == 'discovery':
            result = generator.create_discovery_playlist()
        
        elif playlist_type == 'ultimate':
            result = generator.create_ultimate_wrapped_playlist()
        
        elif playlist_type == 'all':
            result = generator.create_multiple_playlists()
        
        else:
            return jsonify({'error': 'Invalid playlist type'}), 400
        
        return jsonify(result)
